
package org.nasdanika.amur.it.js.renderers;

import org.nasdanika.amur.it.js.exec.*;

import org.nasdanika.amur.it.js.*;
import org.nasdanika.amur.it.js.impl.*;
import java.util.*;

public class FactoryRenderer {


  protected static String nl;
  public static synchronized FactoryRenderer create(String lineSeparator)
  {
    nl = lineSeparator;
    FactoryRenderer result = new FactoryRenderer();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/**" + NL + " * Creates a component instance" + NL + " * Wrap in define()/require() as needed" + NL + " * @param $facade - facade which provides outputs and other configuration" + NL + " * and to which component inputs are bound when component is startd." + NL + " *  " + NL + " *  All component-related ('special') variables start with $ to avoid clash with user-defined variables." + NL + " */" + NL + "function ";
  protected final String TEXT_2 = "Factory($promiseProvider, $facade, $config, $outputs) {" + NL + "" + NL + "\tif (!$promiseProvider) {" + NL + "\t\t// Use global/contextual Q if promise provider is not defined." + NL + "\t\t$promiseProvider = Q;" + NL + "\t}" + NL + "\t" + NL + "\tif (!$facade) {" + NL + "\t\t$facade = {};" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Delay and other promises to wait on before stopping flow" + NL + "\t */" + NL + "\tvar $registeredPromises = [];" + NL + "\t" + NL + "\tvar $timeouts = [];" + NL + "\t" + NL + "\t/**" + NL + "\t * Interval ID's to cancel intervals when flow stops" + NL + "\t */" + NL + "\tvar $intervals = [];" + NL + "\t" + NL + "\t/**" + NL + "\t * Registers a promise. $stop() method waits for registered promises" + NL + "\t * to be fulfilled before stopping the component." + NL + "\t */" + NL + "\tvar $registerPromise = function $registerPromise(promise) {" + NL + "\t\tif (promise) {" + NL + "\t\t\tvar $pidx = $registeredPromises.length;" + NL + "\t\t\t$registeredPromises[$pidx] = promise;" + NL + "\t\t\tpromise.fin(function() {" + NL + "\t\t\t\tdelete $registeredPromises[$pidx];" + NL + "\t\t\t}); " + NL + "\t\t\treturn $pidx;" + NL + "\t\t}" + NL + "\t};" + NL + "\t" + NL + "\t// Returns a function which wraps 'f' function bound to 'bindTo' and invokes it with a delay 'period'." + NL + "\t// The returned function returns a promise which is fulfilled by the return value of the delayed function" + NL + "\t// 'f' after it is invoked. Delayed promises are registered, i.e. facade.$stop() waits for their fulfillment." + NL + "\t// period shall be either a number or a function returning number. If period is a function it is invoked with the same bindTo and arguments as the target function." + NL + "\t// Returned promise has cancel() method to cancel delayed execution." + NL + "\tvar $delay = $config && typeof $config.delay == 'function' ? $config.delay : function $delay(f, bindTo, period) {" + NL + "\t\treturn function() {" + NL + "\t\t\tvar args = arguments;" + NL + "\t\t\tvar deferred = $promiseProvider.defer();" + NL + "\t\t\tvar $rIdx = $registerPromise(deferred.promise);" + NL + "\t\t\t" + NL + "\t\t\tif (typeof period == 'function') {" + NL + "\t\t\t\tperiod = period.apply(bindTo, args);" + NL + "\t\t\t}" + NL + "\t\t\t" + NL + "\t\t\tif (typeof period != 'number') {" + NL + "\t\t\t\tthrow \"Period is not a number: \"+period;" + NL + "\t\t\t}" + NL + "\t\t\t" + NL + "\t\t\tvar $timeoutKey = setTimeout(function() { " + NL + "\t\t\t\t\ttry {" + NL + "\t\t\t\t\t\tdeferred.resolve(f.apply(bindTo, args)); " + NL + "\t\t\t\t\t} catch (e) {" + NL + "\t\t\t\t\t\tdeferred.reject(e);" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}, " + NL + "\t\t\t\tperiod);\t\t\t\t\t\t" + NL + "" + NL + "\t\t\tvar ret = deferred.promise;" + NL + "\t\t\t" + NL + "\t\t\tret.cancel = function() {" + NL + "\t\t\t\t\tclearTimeout($timeoutKey);" + NL + "\t\t\t\t\tdelete $registeredPromises[$rIdx];" + NL + "\t\t\t};" + NL + "\t\t\t" + NL + "\t\t\treturn ret;" + NL + "\t\t};" + NL + "\t};" + NL + "\t" + NL + "\t// Returns a function which wraps 'f' function bound to 'bindTo' and invokes it with a delay 'period'." + NL + "\t// The returned function returns a promise which is fulfilled by the return value of the delayed function" + NL + "\t// 'f' after it is invoked. The promise returned has cancel() method which clears timeout." + NL + "\tvar $timeout = $config && typeof $config.timeout == 'function' ? $config.timeout : function $timeout(f, bindTo, period) {" + NL + "\t\treturn function() {" + NL + "\t\t\tvar args = arguments;" + NL + "\t\t\tvar deferred = $promiseProvider.defer();" + NL + "\t\t\tvar $tidx = $timeouts.length;" + NL + "\t\t\t" + NL + "\t\t\tif (typeof period == 'function') {" + NL + "\t\t\t\tperiod = period.apply(bindTo, args);" + NL + "\t\t\t}" + NL + "\t\t\t" + NL + "\t\t\tif (typeof period != 'number') {" + NL + "\t\t\t\tthrow \"Period is not a number: \"+period;" + NL + "\t\t\t}" + NL + "\t\t\t" + NL + "\t\t\tvar $timeoutKey = setTimeout(function() { " + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tdeferred.resolve(f.apply(bindTo, args)); " + NL + "\t\t\t\t} catch (e) {" + NL + "\t\t\t\t\tdeferred.reject(e);" + NL + "\t\t\t\t} finally {" + NL + "\t\t\t\t\tdelete $timeouts[$tidx];" + NL + "\t\t\t\t}" + NL + "\t\t\t}, " + NL + "\t\t\tperiod);" + NL + "\t\t\t\t" + NL + "\t\t\t$timeouts[$tidx] = $timeoutKey;" + NL + "\t\t\t" + NL + "\t\t\tvar ret = deferred.promise;" + NL + "\t\t\t" + NL + "\t\t\tret.cancel = function() {" + NL + "\t\t\t\t\tclearTimeout($timeoutKey);" + NL + "\t\t\t\t\tdelete $timeouts[$tidx];" + NL + "\t\t\t};" + NL + "\t\t\t" + NL + "\t\t\treturn ret;" + NL + "\t\t};" + NL + "\t};\t" + NL + "\t" + NL + "\t// Returns a function which wraps 'f' function bound to 'bindTo' and invokes it with interval 'period'." + NL + "\t// The returned function returns a promise which is notified with the return value of each scheduled invocation " + NL + "\t// of function 'f'. The promise returned has cancel() method which clears interval." + NL + "\tvar $schedule = $config && typeof $config.schedule == 'function' ? $config.schedule : function $schedule(f, bindTo, period) {" + NL + "\t\treturn function() {" + NL + "\t\t\tvar args = arguments;" + NL + "\t\t\tvar deferred = $promiseProvider.defer();" + NL + "\t\t\tvar idx = $intervals.length;" + NL + "\t\t\t" + NL + "\t\t\tif (typeof period == 'function') {" + NL + "\t\t\t\tperiod = period.apply(bindTo, args);" + NL + "\t\t\t}" + NL + "\t\t\t" + NL + "\t\t\tif (typeof period != 'number') {" + NL + "\t\t\t\tthrow \"Period is not a number: \"+period;" + NL + "\t\t\t}" + NL + "\t\t\t\t" + NL + "\t\t\tvar intervalKey = setInterval(function() { " + NL + "\t\t\t\ttry {" + NL + "\t\t\t\t\tdeferred.notify(f.apply(bindTo, args)); " + NL + "\t\t\t\t} catch (e) {" + NL + "\t\t\t\t\tdeferred.reject(e);" + NL + "\t\t\t\t}" + NL + "\t\t\t}, " + NL + "\t\t\tperiod);" + NL + "\t\t\t\t" + NL + "\t\t\t$intervals[idx] = intervalKey;" + NL + "" + NL + "\t\t\tvar ret = deferred.promise;" + NL + "\t\t\t\t\t\t" + NL + "\t\t\tret.cancel = function() {" + NL + "\t\t\t\t\tclearInterval(intervalKey);" + NL + "\t\t\t\t\tdelete $intervals[idx];" + NL + "\t\t\t};" + NL + "\t\t\t" + NL + "\t\t\treturn ret;" + NL + "\t\t};" + NL + "\t};\t" + NL + "\t" + NL + "\tvar $nextTick = $config && typeof $config.nextTick == 'function' ? $config.nextTick : function $nextTick(f, bindTo) {" + NL + "\t\treturn $delay(f, bindTo, 0);" + NL + "\t};" + NL + "\t" + NL + "\t// Wrapper function for logging exceptions. Useful for troubleshooting." + NL + "\tvar $logError = $config && typeof $config.logError == 'function' ? $config.logError : function $logError(f, bindTo) {" + NL + "\t\treturn function() {" + NL + "\t\t\ttry {" + NL + "\t\t\t\treturn f.apply(bindTo, arguments);" + NL + "\t\t\t} catch (e) {" + NL + "\t\t\t\tconsole.error(e);" + NL + "\t\t\t\tthrow e;" + NL + "\t\t\t}" + NL + "\t\t};\t\t" + NL + "\t};" + NL + "\t" + NL + "\tvar maxInvocationDepth = $config && $config.maxInvocationDepth || 10000;" + NL + "\t" + NL + "\tvar $invocationCounter = 0;" + NL + "\t" + NL + "\tvar $createInvocation = $config && typeof $config.createInvocation == 'function' ? $config.createInvocation : function $createInvocation(parentInvocations) {" + NL + "\t\tvar invocation = {" + NL + "\t\t\tcreated : new Date()," + NL + "\t\t\tchildren : []," + NL + "\t\t\tdepth : 0," + NL + "\t\t\tid : $invocationCounter++" + NL + "\t\t};" + NL + "\t\t" + NL + "\t\tif (parentInvocations) {" + NL + "\t\t\tinvocation.parents = parentInvocations;" + NL + "\t\t\tfor (var i=0; i<parentInvocations.length; ++i) {" + NL + "\t\t\t\tparentInvocations[i].children.push(invocation);" + NL + "\t\t\t\tif (parentInvocations[i].depth+1>invocation.depth) {" + NL + "\t\t\t\t\tinvocation.depth = parentInvocations[i].depth+1;" + NL + "\t\t\t\t}" + NL + "\t\t\t}\t" + NL + "\t\t\tif (invocation.depth>maxInvocationDepth) {" + NL + "\t\t\t\tthrow \"Invocation depth exceeds \"+maxInvocationDepth+\", possibly an infinite loop\";" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\treturn invocation;" + NL + "\t};" + NL + "\t" + NL + "\t/**" + NL + "\t * Wraps f function and returns function which tokenizes argument at argIdx. " + NL + "\t * If argument at argIdx is array then resulting function iterates over elements and returns" + NL + "\t * array of return values from individual invocation." + NL + "\t * if argument at argIdx is object then resulting function iterates over object keys and" + NL + "\t * returns an object with individual return values corresponding to keys." + NL + "\t * Otherwise argument is passed as-is. " + NL + "\t */" + NL + "\tvar $tokenize = $config && typeof $config.tokenize == 'function' ? $config.tokenize : function $tokenize(f, argIdx) {" + NL + "\t\treturn function tokenized() {" + NL + "\t\t\tif (arguments.length>argIdx && typeof arguments[argIdx] == \"object\") {" + NL + "\t\t\t\tvar args = [];" + NL + "\t\t\t\tfor (var i in arguments) {" + NL + "\t\t\t\t\targs[i] = arguments[i];" + NL + "\t\t\t\t}" + NL + "\t\t\t\tvar ret = Array.isArray(arguments[argIdx]) ? [] : {};" + NL + "\t\t\t\tfor (var i in arguments[argIdx]) {" + NL + "\t\t\t\t\targs[argIdx]=arguments[argIdx][i];" + NL + "\t\t\t\t\tret[i]=f.apply(this, args);" + NL + "\t\t\t\t}" + NL + "\t\t\t\treturn ret;" + NL + "\t\t\t}" + NL + "\t\t\treturn f.apply(this, arguments);" + NL + "\t\t};" + NL + "\t};" + NL + "\t" + NL + "\t/* Extend function. Uses jQuery.extend if available. Uses implementation factored out from jQuery 2 otherwise. */" + NL + "\tvar extend = $config && typeof $config.extend === \"function\" ? $config.extend : function() {" + NL + "\t\tvar options, name, src, copy, copyIsArray, clone," + NL + "\t\t\ttarget = arguments[0] || {}," + NL + "\t\t\ti = 1," + NL + "\t\t\tlength = arguments.length," + NL + "\t\t\tdeep = false;" + NL + "\t" + NL + "\t\t// Handle a deep copy situation" + NL + "\t\tif ( typeof target === \"boolean\" ) {" + NL + "\t\t\tdeep = target;" + NL + "\t" + NL + "\t\t\t// skip the boolean and the target" + NL + "\t\t\ttarget = arguments[ i ] || {};" + NL + "\t\t\ti++;" + NL + "\t\t}" + NL + "\t" + NL + "\t\t// Handle case when target is a string or something (possible in deep copy)" + NL + "\t\tif ( typeof target !== \"object\" && typeof target !== \"function\") {" + NL + "\t\t\ttarget = {};" + NL + "\t\t}" + NL + "\t" + NL + "\t\t// extend jQuery itself if only one argument is passed" + NL + "\t\tif ( i === length ) {" + NL + "\t\t\ttarget = this;" + NL + "\t\t\ti--;" + NL + "\t\t}" + NL + "\t" + NL + "\t\tfor ( ; i < length; i++ ) {" + NL + "\t\t\t// Only deal with non-null/undefined values" + NL + "\t\t\tif ( (options = arguments[ i ]) != null ) {" + NL + "\t\t\t\t// Extend the base object" + NL + "\t\t\t\tfor ( name in options ) {" + NL + "\t\t\t\t\tsrc = target[ name ];" + NL + "\t\t\t\t\tcopy = options[ name ];" + NL + "\t" + NL + "\t\t\t\t\t// Prevent never-ending loop" + NL + "\t\t\t\t\tif ( target === copy ) {" + NL + "\t\t\t\t\t\tcontinue;" + NL + "\t\t\t\t\t}" + NL + "\t" + NL + "\t\t\t\t\t// Recurse if we're merging plain objects or arrays" + NL + "\t\t\t\t\tif ( deep && copy && ( typeof copy === \"object\" || (copyIsArray = Array.isArray(copy)) ) ) {" + NL + "\t\t\t\t\t\tif ( copyIsArray ) {" + NL + "\t\t\t\t\t\t\tcopyIsArray = false;" + NL + "\t\t\t\t\t\t\tclone = src && Array.isArray(src) ? src : [];" + NL + "\t" + NL + "\t\t\t\t\t\t} else {" + NL + "\t\t\t\t\t\t\tclone = src && typeof src === \"object\" ? src : {};" + NL + "\t\t\t\t\t\t}" + NL + "\t" + NL + "\t\t\t\t\t\t// Never move original objects, clone them" + NL + "\t\t\t\t\t\ttarget[ name ] = extend( deep, clone, copy );" + NL + "\t" + NL + "\t\t\t\t\t// Don't bring in undefined values" + NL + "\t\t\t\t\t} else if ( copy !== undefined ) {" + NL + "\t\t\t\t\t\ttarget[ name ] = copy;" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t" + NL + "\t\t// Return the modified object" + NL + "\t\treturn target;" + NL + "\t};" + NL + "\t" + NL + "\t/**" + NL + "\t * Extend function used by clone(). Uses jQuery.extend() if available" + NL + "\t */" + NL + "\tvar $clone = $config && typeof $config.clone == 'function' ? $config.clone : function $clone(o, deep) {\t" + NL + "\t\treturn deep ? extend(true, {}, o) : extend({}, o);" + NL + "\t};" + NL + "\t" + NL + "\t/**" + NL + "\t * Performs join." + NL + "\t * @param inputName This input name" + NL + "\t * @param collectors - a hash of arrays. " + NL + "\t * Each element in array is an object with invocation property, and promise to notify of joins/consumption." + NL + "\t * @param conditions Array of condition functions. Conditions are invoked with the same parameters as" + NL + "\t * handler and can consume inputs." + NL + "\t * @param handler Handler to invoke on successful join. Handler return value is dispatched to inputs as a progress" + NL + "\t * notification." + NL + "\t * @param outer Perform outer join if true. " + NL + "\t * @param argMapper Optional function which maps join arguments to condition and handler arguments." + NL + "\t */" + NL + "\tvar $join = $config && typeof $config.join == 'function' ? $config.join : function $join(" + NL + "\t\t\tinputName, " + NL + "\t\t\tinputData," + NL + "\t\t\tcollectors, " + NL + "\t\t\tcontextFactory, " + NL + "\t\t\tconditions, " + NL + "\t\t\thandler, " + NL + "\t\t\touter, " + NL + "\t\t\targMapper) {" + NL + "\t\t\t" + NL + "\t\tif (collectors) {\t\t\t\t\t" + NL + "\t\t\tvar inputIdx = collectors[inputName].length;" + NL + "\t\t\tvar inputEntry = $promiseProvider.defer();" + NL + "\t\t\tcollectors[inputName].push(inputEntry);" + NL + "\t\t\t" + NL + "\t\t\t// Consumes entry " + NL + "\t\t\tinputEntry.consume = function() {" + NL + "\t\t\t\tdelete collectors[inputName][inputIdx];" + NL + "\t\t\t\tthis.resolve(true);" + NL + "\t\t\t\tthis.consumed = true;" + NL + "\t\t\t};" + NL + "\t\t\t" + NL + "\t\t\tinputEntry.data = inputData;" + NL + "\t\t\t" + NL + "\t\t\tvar collectorNames = [];\t\t\t\t" + NL + "\t\t\tfor (var i in collectors) {" + NL + "\t\t\t\tcollectorNames.push(i);" + NL + "\t\t\t}" + NL + "\t\t\t" + NL + "\t\t\t// Joins inputs" + NL + "\t\t\tfunction _join(collectorIdx, collected) {\t\t" + NL + "\t\t\t\tif (collectorIdx==collectorNames.length) {" + NL + "\t\t\t\t\tvar context = contextFactory && contextFactory(collected);" + NL + "\t\t\t\t\tvar jArgs = typeof argMapper == 'function' ? argMapper(collected) : collected;" + NL + "\t\t\t\t\tif (conditions) {" + NL + "\t\t\t\t\t\tfor (var ci in conditions) {" + NL + "\t\t\t\t\t\t\tif (conditions[ci]) {" + NL + "\t\t\t\t\t\t\t\tvar cr = conditions[ci].apply(context, jArgs);" + NL + "\t\t\t\t\t\t\t\tif (!cr) {" + NL + "\t\t\t\t\t\t\t\t\treturn;" + NL + "\t\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\t" + NL + "\t\t\t\t\tfor (var c in collected) {" + NL + "\t\t\t\t\t\tif (collected[c] && collected[c].consumed) {" + NL + "\t\t\t\t\t\t\treturn;" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\t" + NL + "\t\t\t\t\t// Collected all, invoke handler." + NL + "\t\t\t\t\tvar result = handler.apply(context, jArgs);" + NL + "\t\t\t\t\tfor (var c in collected) {" + NL + "\t\t\t\t\t\tif (collectorNames[c] == inputName) {" + NL + "\t\t\t\t\t\t\tif (!collected[c].promise.results) {" + NL + "\t\t\t\t\t\t\t\tcollected[c].promise.results = [];" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\tcollected[c].promise.results.push(result);" + NL + "\t\t\t\t\t\t} else if (collected[c] && typeof collected[c].notify == 'function') {" + NL + "\t\t\t\t\t\t\tcollected[c].notify(result); // Notifying promises of a join result." + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t} else if (collectorNames[collectorIdx] == inputName) {" + NL + "\t\t\t\t\tcollected[collectorIdx] = inputEntry;" + NL + "\t\t\t\t\t_join(collectorIdx+1, collected);" + NL + "\t\t\t\t} else {" + NL + "\t\t\t\t\tif (outer) {" + NL + "\t\t\t\t\t\tcollected[collectorIdx]=null;" + NL + "\t\t\t\t\t\t_join(collectorIdx+1, collected);" + NL + "\t\t\t\t\t\tfor (var i=0; i<=collectorIdx; ++i) {" + NL + "\t\t\t\t\t\t\tif (collected[i] && collected[i].consumed) {" + NL + "\t\t\t\t\t\t\t\treturn;" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\t" + NL + "\t\t\t\t\tfor (var c in collectors[collectorNames[collectorIdx]]) {" + NL + "\t\t\t\t\t\tcollected[collectorIdx]=collectors[collectorNames[collectorIdx]][c];" + NL + "\t\t\t\t\t\tif (!collected[collectorIdx].consumed) {" + NL + "\t\t\t\t\t\t\t_join(collectorIdx+1, collected);" + NL + "\t\t\t\t\t\t\tfor (var i=0; i<=collectorIdx; ++i) {" + NL + "\t\t\t\t\t\t\t\tif (collected[i] && collected[i].consumed) {" + NL + "\t\t\t\t\t\t\t\t\treturn;" + NL + "\t\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t\t}" + NL + "\t\t\t\t\t\t}" + NL + "\t\t\t\t\t}\t\t\t\t\t\t" + NL + "\t\t\t\t}" + NL;
  protected final String TEXT_3 = "\t\t\t}" + NL + "\t\t\t" + NL + "\t\t\t_join(0, []);" + NL + "\t\t\t" + NL + "\t\t\treturn inputEntry.promise;" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\tconsole.warn(\"Cannot join - no collectors\");" + NL + "\t};" + NL + "\t" + NL + "\t/**" + NL + "\t * Join argument is a deferred with invocation as data, mapped argument is an object with invocation's data as data and consume() function." + NL + "\t */" + NL + "\tvar $joinArgsMapper = $config && typeof $config.joinArgsMapper == 'function' ? $config.joinArgsMapper : function $joinArgsMapper(args) {" + NL + "\t\tvar ret = [];" + NL + "\t\tfor (var i in args) {" + NL + "\t\t\tret.push(args[i] && { data : args[i].data.data, consume : args[i].consume.bind(args[i]) });" + NL + "\t\t}" + NL + "\t\treturn ret;" + NL + "\t};" + NL + "" + NL + "\t/**" + NL + "\t * Retrieves join collectors from container. Creates if necessary." + NL + "\t */" + NL + "\tfunction $getJoinCollectors(container, property, inputNames) {" + NL + "\t\tif (container) {" + NL + "\t\t\tif (!container[property]) {" + NL + "\t\t\t\tcontainer[property] = {};" + NL + "\t\t\t\tfor (var i in inputNames) {" + NL + "\t\t\t\t\tcontainer[property][inputNames[i]] = [];" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t\treturn container[property];" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "\t/**" + NL + "\t * Traverses invocation parents to find a path to the join fork invocation" + NL + "\t * Invocation - invocation to start from." + NL + "\t * Path - invocation path." + NL + "\t */ " + NL + "\tfunction $traversePath(invocation, path) {" + NL + "\t\tif (path.length==0) {" + NL + "\t\t\treturn invocation;" + NL + "\t\t}" + NL + "\t\t" + NL + "\t\tif (invocation.parents) {" + NL + "\t\t\tfor (var p in invocation.parents) {" + NL + "\t\t\t\tif (invocation.parents[p].path = path[0]) {" + NL + "\t\t\t\t\tvar ret = $traversePath(invocation.parents[p], path.slice(1));" + NL + "\t\t\t\t\tif (ret) {" + NL + "\t\t\t\t\t\treturn ret;" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t}" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "\tfunction $resolveInvocationJoinCollectors(invocation, paths) {" + NL + "\t\tif (paths) {" + NL + "\t\t\tfor (var p in paths) {" + NL + "\t\t\t\tvar resolved = $traversePath(invocation, paths[p]);" + NL + "\t\t\t\tif (resolved) {" + NL + "\t\t\t\t\tif (!resolved.joinCollectors) {" + NL + "\t\t\t\t\t\tresolved.joinCollectors = {};" + NL + "\t\t\t\t\t}" + NL + "\t\t\t\t\treturn resolved.joinCollectors;" + NL + "\t\t\t\t}\t\t\t" + NL + "\t\t\t}" + NL + "\t\t}" + NL + "\t}" + NL + "\t" + NL + "\t// Helper function to invoke $start/$stop in context of start/stop invocation" + NL + "\t// returns a function which invockes f in context and " + NL + "\t// returns a promise of invocation for chaining." + NL + "\tfunction $invokeInContext(f, invocationName, component) {" + NL + "\t\treturn function(invocation) {" + NL + "\t\t\tif (!invocation) {" + NL + "\t\t\t\tthrow \"Invocation is mandatory\";" + NL + "\t\t\t}" + NL + "\t\t\tvar context = component.$createContext(invocationName, [invocation]);\t\t" + NL + "\t\t\tvar fb = $config && $config.logErrors ? $logError(f, context) : f.bind(context);" + NL + "\t\t\treturn $promiseProvider.when(fb()).then(function() { return invocation; });" + NL + "\t\t};\t" + NL + "\t} " + NL + "\t\t" + NL + "\t// Components hierarchy" + NL + "\tvar $ajsComponent = ";
  protected final String TEXT_4 = ";" + NL + "\t" + NL + "\t$ajsComponent.$init();" + NL + "\t" + NL + "\t// TODO - merge state if $config.loadState(component) is function" + NL + "\t// TODO - pass state to stop, if $config.storeState(component) is function" + NL + "\t" + NL + "\t$facade.$stop = function() {" + NL + "\t\t// Clearing all intervals" + NL + "\t\tfor (var i in $intervals) {" + NL + "\t\t\tclearInterval($intervals[i]);" + NL + "\t\t}" + NL + "" + NL + "\t\t// Clearing remaining timeouts" + NL + "\t\tfor (var i in $timeouts) {" + NL + "\t\t\tclearTimeout($timeouts[i]);" + NL + "\t\t}\t\t" + NL + "\t\t\t" + NL + "\t\t// Wait for all delayed invocations to finish then stop." + NL + "\t\tvar $stopInvocation = $createInvocation();" + NL + "\t\t$stopInvocation.path='$facade.$stop';" + NL + "\t\t$promiseProvider.allSettled($registeredPromises).then($ajsComponent.$children.$starter.$stopDeferred.resolve.bind($facade, $stopInvocation));" + NL + "\t\treturn $ajsComponent.$children.$starter.$stopPromise;" + NL + "\t};" + NL + "" + NL + "\tvar $startInvocation = $createInvocation();" + NL + "\t$startInvocation.path='start';" + NL + "\t" + NL + "\treturn $ajsComponent.$children.$starter.$doStart($startInvocation).then(function() { return $facade; });\t" + NL + "}";

public String generate(org.nasdanika.amur.it.js.exec.Component execComponent, java.util.Map<Object, Object> context)
  {
    final StringBuffer stringBuffer = new StringBuffer();
    stringBuffer.append(TEXT_1);
    stringBuffer.append(context.get("component.name"));
    stringBuffer.append(TEXT_2);
    stringBuffer.append(TEXT_3);
    stringBuffer.append(context.get("component.definition"));
    stringBuffer.append(TEXT_4);
    return stringBuffer.toString();
  }
}